print "hello world"

len = x => {
    x :: _ => result += 1
}

sum = l => {
    l :: x => result += x
}

zip = (a, b) => {
  len(a) == len(b) # assert same length
  :> 0..len(a) :: i => (a[i], b[i])
}

dot = (a, b) => {
  :> sum(zip(a, b) :: (x, y) => x * y)
}

transpose = A => {
    rows = len(A)
    cols = len(A[0])
    :> 0..cols :: y => 0..rows :: x => A[x][y]
}

matmul = (A, B) => {
    (n1, m1) = (len(A), len(A[0]))
    (n2, m2) = (len(B), len(B[0]))
    m1 == n2 # assert columns or A match rows of B
    B = transpose(B) # transpose is easier to work with
    :> 0..n1 :: i => {
        :> 0..m2 :: ii => {
            :> dot(A[i],  B[ii])
        }
    }
}

X = [
    [1, 2, 3],
    [2, 3, 1],
    [3, 2, 1]
]

Y = [
    [0, 1, 2],
    [1, 2, 1],
    [2, 1, 0]
]

print matmul(X, Y)

# Should print:
# [[8, 8, 4], 
#  [5, 9, 7], 
#  [4, 8, 8]]

linspace = (start, end, n) => {
    diff = end - start
    step = diff / n
    :> 0..n :: i => start + step * i
}
